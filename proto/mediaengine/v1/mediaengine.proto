syntax = "proto3";

package mediaengine.v1;

option go_package = "github.com/friendsincode/grimnir_radio/proto/mediaengine/v1;mediaenginev1";

import "google/protobuf/timestamp.proto";

// MediaEngine service controls audio playback, DSP processing, and output encoding.
service MediaEngine {
  // LoadGraph loads a DSP processing graph configuration
  rpc LoadGraph(LoadGraphRequest) returns (LoadGraphResponse);

  // Play starts playback of a media source
  rpc Play(PlayRequest) returns (PlayResponse);

  // Stop halts playback
  rpc Stop(StopRequest) returns (StopResponse);

  // Fade initiates a crossfade between sources
  rpc Fade(FadeRequest) returns (FadeResponse);

  // InsertEmergency immediately plays emergency content
  rpc InsertEmergency(InsertEmergencyRequest) returns (InsertEmergencyResponse);

  // RouteLive routes a live input stream
  rpc RouteLive(RouteLiveRequest) returns (RouteLiveResponse);

  // StreamTelemetry streams real-time audio telemetry
  rpc StreamTelemetry(TelemetryRequest) returns (stream TelemetryData);

  // GetStatus returns current engine status
  rpc GetStatus(StatusRequest) returns (StatusResponse);

  // AnalyzeMedia performs media analysis (metadata, loudness, cue points)
  rpc AnalyzeMedia(AnalyzeMediaRequest) returns (AnalyzeMediaResponse);

  // ExtractArtwork extracts embedded album art from media
  rpc ExtractArtwork(ExtractArtworkRequest) returns (ExtractArtworkResponse);

  // GenerateWaveform generates peak/RMS waveform data for visualization
  rpc GenerateWaveform(GenerateWaveformRequest) returns (GenerateWaveformResponse);
}

// LoadGraphRequest contains DSP graph configuration
message LoadGraphRequest {
  string station_id = 1;
  string mount_id = 2;
  DSPGraph graph = 3;
}

message LoadGraphResponse {
  string graph_handle = 1; // Unique identifier for the loaded graph
  bool success = 2;
  string error = 3;
}

// PlayRequest initiates playback
message PlayRequest {
  string station_id = 1;
  string mount_id = 2;
  SourceConfig source = 3;
  CuePoints cue_points = 4;
  FadeConfig fade = 5;
  int32 priority = 6; // Priority level (0-4)
}

message PlayResponse {
  bool success = 1;
  string playback_id = 2;
  string error = 3;
}

// StopRequest halts playback
message StopRequest {
  string station_id = 1;
  string mount_id = 2;
  bool immediate = 3; // If true, stop without fade
}

message StopResponse {
  bool success = 1;
  string error = 2;
}

// FadeRequest initiates crossfade
message FadeRequest {
  string station_id = 1;
  string mount_id = 2;
  SourceConfig next_source = 3;
  CuePoints next_cue_points = 4;
  FadeConfig fade_config = 5;
}

message FadeResponse {
  bool success = 1;
  string fade_id = 2;
  int64 estimated_duration_ms = 3;
  string error = 4;
}

// InsertEmergencyRequest for emergency broadcasts
message InsertEmergencyRequest {
  string station_id = 1;
  string mount_id = 2;
  SourceConfig source = 3;
}

message InsertEmergencyResponse {
  bool success = 1;
  string emergency_id = 2;
  string error = 3;
}

// RouteLiveRequest routes live input
message RouteLiveRequest {
  string station_id = 1;
  string mount_id = 2;
  string session_id = 3;        // Live session ID
  LiveInputType input_type = 4; // Type of live input
  string input_url = 5;         // Input URL (for HTTP/Icecast/SRT)
  int32 port = 6;               // Port (for RTP/UDP)
  string dsp_graph_handle = 7;  // DSP graph to apply
  int32 fade_in_ms = 8;         // Fade in duration
  LiveInputConfig input = 9;    // Legacy field (deprecated)
}

message RouteLiveResponse {
  bool success = 1;
  string session_id = 2;        // Live session ID
  string message = 3;           // Status message
  string live_id = 4;           // Legacy field (deprecated)
  string error = 5;             // Legacy field (deprecated)
}

// TelemetryRequest for streaming telemetry
message TelemetryRequest {
  string station_id = 1;
  string mount_id = 2;
  int32 interval_ms = 3; // Update interval in milliseconds
}

// TelemetryData contains real-time audio metrics
message TelemetryData {
  string station_id = 1;
  string mount_id = 2;
  google.protobuf.Timestamp timestamp = 3;

  // Audio levels
  float audio_level_l = 4;  // Left channel RMS (-60 to 0 dBFS)
  float audio_level_r = 5;  // Right channel RMS
  float peak_level_l = 6;   // Left channel peak
  float peak_level_r = 7;   // Right channel peak

  // Loudness
  float loudness_lufs = 8;  // Integrated loudness (LUFS)
  float momentary_lufs = 9; // Momentary loudness
  float short_term_lufs = 10; // Short-term loudness

  // Buffer state
  int64 buffer_depth_ms = 11;
  int32 buffer_fill_percent = 12;
  int64 underrun_count = 13;

  // Playback state
  PlaybackState state = 14;
  int64 position_ms = 15; // Current playback position
  int64 duration_ms = 16; // Total duration (if known)
}

// StatusRequest queries engine status
message StatusRequest {
  string station_id = 1;
  string mount_id = 2;
}

message StatusResponse {
  bool running = 1;
  PlaybackState state = 2;
  string current_source_id = 3;
  int64 uptime_seconds = 4;
  string graph_handle = 5;
  map<string, string> metadata = 6;
}

// SourceConfig describes an audio source
message SourceConfig {
  SourceType type = 1;
  string source_id = 2; // Media ID, webstream URL, etc.
  string path = 3;      // File path for media sources
  map<string, string> metadata = 4;
}

// CuePoints for seamless mixing
message CuePoints {
  float intro_end = 1;  // End of intro in seconds
  float outro_in = 2;   // Start of outro in seconds
}

// FadeConfig for crossfades
message FadeConfig {
  int32 fade_in_ms = 1;
  int32 fade_out_ms = 2;
  FadeCurve curve = 3;
}

// LiveInputConfig for live streaming
message LiveInputConfig {
  string input_url = 1;      // Harbor/HTTP input URL
  string auth_token = 2;     // Authentication token
  int32 buffer_ms = 3;       // Input buffer size
  bool apply_processing = 4; // Apply DSP graph to live input
}

// DSPGraph defines audio processing chain
message DSPGraph {
  repeated DSPNode nodes = 1;
  repeated DSPConnection connections = 2;
}

// AnalyzeMediaRequest requests media analysis
message AnalyzeMediaRequest {
  string file_path = 1;  // Path to the media file to analyze
}

// AnalyzeMediaResponse contains analysis results
message AnalyzeMediaResponse {
  bool success = 1;
  string error = 2;

  // Duration in milliseconds
  int64 duration_ms = 3;

  // Audio properties
  int32 bitrate = 4;      // Bitrate in kbps
  int32 sample_rate = 5;  // Sample rate in Hz
  int32 channels = 6;     // Number of audio channels
  string codec = 7;       // Audio codec name

  // Loudness analysis
  float loudness_lufs = 8;       // Integrated loudness (LUFS)
  float loudness_range = 9;      // Loudness range (LU)
  float true_peak = 10;          // True peak (dBTP)
  float replay_gain = 11;        // Replay gain adjustment (dB)

  // Cue points (in seconds)
  float intro_end = 12;   // End of intro
  float outro_in = 13;    // Start of outro

  // Metadata from file tags
  MediaMetadata metadata = 14;
}

// MediaMetadata contains ID3/Vorbis/etc tags
message MediaMetadata {
  string title = 1;
  string artist = 2;
  string album = 3;
  string genre = 4;
  string year = 5;
  int32 track_number = 6;
  string album_artist = 7;
  string composer = 8;
  string isrc = 9;
  map<string, string> extra_tags = 10;  // Any additional tags
}

// ExtractArtworkRequest requests artwork extraction
message ExtractArtworkRequest {
  string file_path = 1;      // Path to the media file
  int32 max_width = 2;       // Maximum width for resizing (0 = no resize)
  int32 max_height = 3;      // Maximum height for resizing (0 = no resize)
  string format = 4;         // Output format: "jpeg", "png", "webp" (default: jpeg)
  int32 quality = 5;         // JPEG/WebP quality 1-100 (default: 85)
}

// ExtractArtworkResponse contains extracted artwork
message ExtractArtworkResponse {
  bool success = 1;
  string error = 2;
  bytes artwork_data = 3;    // Raw image data
  string mime_type = 4;      // MIME type of the image (image/jpeg, image/png, etc)
  int32 width = 5;           // Image width in pixels
  int32 height = 6;          // Image height in pixels
}

// GenerateWaveformRequest requests waveform generation
message GenerateWaveformRequest {
  string file_path = 1;          // Path to the media file
  int32 samples_per_second = 2;  // Number of samples per second (default: 10)
  WaveformType type = 3;         // Type of waveform data
}

// WaveformType specifies the type of waveform data to generate
enum WaveformType {
  WAVEFORM_TYPE_UNSPECIFIED = 0;
  WAVEFORM_TYPE_PEAK = 1;        // Peak amplitude values
  WAVEFORM_TYPE_RMS = 2;         // RMS values
  WAVEFORM_TYPE_BOTH = 3;        // Both peak and RMS
}

// GenerateWaveformResponse contains waveform data
message GenerateWaveformResponse {
  bool success = 1;
  string error = 2;
  int32 sample_rate = 3;         // Samples per second in the response
  int64 duration_ms = 4;         // Total duration in milliseconds
  repeated float peak_left = 5;  // Left channel peak values (0.0-1.0)
  repeated float peak_right = 6; // Right channel peak values (0.0-1.0)
  repeated float rms_left = 7;   // Left channel RMS values (0.0-1.0)
  repeated float rms_right = 8;  // Right channel RMS values (0.0-1.0)
}

// Enums

enum SourceType {
  SOURCE_TYPE_UNSPECIFIED = 0;
  SOURCE_TYPE_MEDIA = 1;
  SOURCE_TYPE_WEBSTREAM = 2;
  SOURCE_TYPE_LIVE = 3;
  SOURCE_TYPE_FALLBACK = 4;
  SOURCE_TYPE_EMERGENCY = 5;
}

enum LiveInputType {
  LIVE_INPUT_TYPE_UNSPECIFIED = 0;
  LIVE_INPUT_TYPE_ICECAST = 1; // Icecast/HTTP source
  LIVE_INPUT_TYPE_RTP = 2;     // RTP/UDP stream
  LIVE_INPUT_TYPE_SRT = 3;     // Secure Reliable Transport
  LIVE_INPUT_TYPE_WEBRTC = 4;  // WebRTC stream
}

enum PlaybackState {
  PLAYBACK_STATE_UNSPECIFIED = 0;
  PLAYBACK_STATE_IDLE = 1;
  PLAYBACK_STATE_LOADING = 2;
  PLAYBACK_STATE_PLAYING = 3;
  PLAYBACK_STATE_FADING = 4;
  PLAYBACK_STATE_PAUSED = 5;
  PLAYBACK_STATE_ERROR = 6;
}

enum FadeCurve {
  FADE_CURVE_UNSPECIFIED = 0;
  FADE_CURVE_LINEAR = 1;
  FADE_CURVE_LOGARITHMIC = 2;
  FADE_CURVE_EXPONENTIAL = 3;
  FADE_CURVE_SCURVE = 4; // S-curve (smooth)
}

// DSPNode represents a processing element
message DSPNode {
  string id = 1;
  NodeType type = 2;
  map<string, string> params = 3;
}

// DSPConnection links nodes
message DSPConnection {
  string from_node = 1;
  string to_node = 2;
  int32 from_pad = 3;
  int32 to_pad = 4;
}

enum NodeType {
  NODE_TYPE_UNSPECIFIED = 0;
  NODE_TYPE_INPUT = 1;
  NODE_TYPE_OUTPUT = 2;
  NODE_TYPE_LOUDNESS_NORMALIZE = 3;
  NODE_TYPE_AGC = 4;
  NODE_TYPE_COMPRESSOR = 5;
  NODE_TYPE_LIMITER = 6;
  NODE_TYPE_EQUALIZER = 7;
  NODE_TYPE_GATE = 8;
  NODE_TYPE_SILENCE_DETECTOR = 9;
  NODE_TYPE_LEVEL_METER = 10;
  NODE_TYPE_MIX = 11;
  NODE_TYPE_DUCK = 12; // Audio ducking
}
